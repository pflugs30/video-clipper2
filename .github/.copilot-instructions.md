# Copilot Instructions for Video Clipper v0.1

## Project Overview
Video Clipper is a desktop application for creating and exporting video clips. Built with Electron, React, and Vite, it allows users to open video files, mark in/out points, create a list of clips, and export them using ffmpeg. This is currently a v0.1 skeleton/starting point designed for extensibility.

## Technology Stack
- **Frontend**: React 18.2 with TypeScript
- **Desktop Framework**: Electron
- **Build Tool**: Vite 4.3
- **Video Player**: Video.js 8.0
- **Module System**: ESM (ES Modules)
- **Language**: TypeScript 5.0 with strict mode enabled
- **Styling**: Tailwind CSS (class-based utility styles)
- **Video Processing**: ffmpeg (stub implementation, needs full integration)

## Architecture Guidelines

### Application Structure
```
electron/          # Main and preload process code
  main.ts         # Electron main process entry point
  preload.ts      # Preload script for IPC bridge
src/              # React renderer process
  App.tsx         # Root component
  main.tsx        # React entry point
  components/     # React UI components
  state/          # State management (React Context)
```

### Process Architecture
- **Main Process** (`electron/main.ts`): Handles native OS interactions, file dialogs, and ffmpeg spawning
- **Renderer Process** (`src/`): React application for UI
- **IPC Communication**: Uses Electron's `ipcMain`/`ipcRenderer` pattern with contextIsolation enabled
- **Preload Script** (`electron/preload.ts`): Exposes safe IPC methods via `window.electronAPI`

### State Management
- Uses React Context API (`ProjectProvider` and `useProjectStore`)
- State is held in memory (not persisted to disk in v0.1)
- Single source of truth for clips, selections, and mark points

## Coding Standards

### TypeScript Configuration
- **Target**: ES2020
- **Module**: ESNext (ES Modules)
- **JSX**: react-jsx
- **Strict Mode**: Always enabled
- All new files must be TypeScript (`.ts` or `.tsx`)

### Naming Conventions
- **Variables/Functions**: camelCase (e.g., `handleOpenVideo`, `markInTime`)
- **React Components**: PascalCase (e.g., `VideoPlayer`, `ClipList`)
- **Interfaces/Types**: PascalCase (e.g., `Clip`, `ProjectState`)
- **Files**: 
  - Components: PascalCase (e.g., `VideoPlayer.tsx`)
  - Utilities/State: camelCase (e.g., `projectStore.ts`)
  - Main process files: camelCase (e.g., `main.ts`)

### File Organization
- React components go in `src/components/`
- State management code goes in `src/state/`
- Electron main process code goes in `electron/`
- Use named exports for components and utilities
- One component per file

### Import Style
```typescript
// Prefer named imports
import { useState, useEffect } from 'react';
import { app, BrowserWindow } from 'electron';

// Use relative paths for local modules
import VideoPlayer from './components/VideoPlayer';
import { useProjectStore } from './state/projectStore';
```

### Code Documentation
- Use JSDoc comments for functions and components
- Describe the purpose and behavior, especially for IPC handlers
- Document all interface properties
- Example:
```typescript
/**
 * Open a video using the native dialog exposed by the preload script. On success,
 * store the file path and reset the project (if needed).
 */
const handleOpenVideo = async () => {
  // Implementation
};
```

## Business Domain Context

### Core Concepts
- **Clip**: A segment of video defined by in/out timecode points (in seconds)
- **Mark In/Out**: The start and end points for the next clip to be created
- **Source Video**: The original video file being clipped
- **Export**: The process of creating a new video file from a clip using ffmpeg

### User Workflow
1. User opens a video file via native file dialog
2. User watches video and marks in/out points using keyboard shortcuts (`i` for in, `o` for out)
3. User adds clip to the list (`a` or "Add Clip" button)
4. User selects clips from the list
5. User exports selected clips (currently stub implementation)

### Timecode Format
- All times are stored as **seconds** (number type)
- Display format should be human-readable (HH:MM:SS or MM:SS.mmm)
- Video.js provides time in seconds

## Development Patterns

### Preferred Approaches

#### IPC Communication Pattern
```typescript
// In preload.ts - expose safe methods
contextBridge.exposeInMainWorld('electronAPI', {
  openVideo: () => ipcRenderer.invoke('dialog:openVideo'),
  exportClip: (sourcePath: string, clip: Clip) => 
    ipcRenderer.invoke('export:clip', sourcePath, clip)
});

// In main.ts - handle requests
ipcMain.handle('dialog:openVideo', async () => {
  const result = await dialog.showOpenDialog({...});
  return result.filePaths[0];
});

// In React - use via window.electronAPI
const filePath = await (window as any).electronAPI.openVideo();
```

#### React Component Structure
```typescript
// Preferred component structure
interface ComponentProps {
  // Props interface at top of file
  id: string;
  onAction?: () => void;
}

/**
 * Brief description of component purpose.
 */
const Component: React.FC<ComponentProps> = ({ id, onAction }) => {
  // Hooks first
  const [state, setState] = useState<Type>(initialValue);
  
  // Event handlers
  const handleEvent = () => {
    // Implementation
  };
  
  // Render
  return (
    <div className="utility-classes">
      {/* JSX */}
    </div>
  );
};

export default Component;
```

#### State Management Pattern
- Use the `useProjectStore()` hook to access global state
- Don't prop-drill; use context for shared state
- Keep component-local state in `useState` when it doesn't need to be shared
- State updaters should be descriptive functions (e.g., `markIn`, `addClipFromMarks`)

#### Keyboard Shortcuts
- Implement keyboard handlers at the appropriate level (App or component)
- Use the pattern: `i` = mark in, `o` = mark out, `a` = add clip
- Consider accessibility (don't override critical browser shortcuts)

### Things to Avoid

#### Don't Use
- Class components (use functional components with hooks)
- Default exports where named exports would be clearer (exceptions: main component files)
- `any` type unless interfacing with untyped libraries (use proper typing or `unknown`)
- CommonJS (`require`/`module.exports`) - this project uses ESM
- Inline styles - use Tailwind utility classes
- Direct DOM manipulation - use React state and refs

#### Anti-Patterns
- **Don't** manipulate video or ffmpeg in the renderer process - use IPC to main process
- **Don't** store large video data in React state - only store file paths and metadata
- **Don't** use `remote` module (deprecated in Electron)
- **Don't** disable contextIsolation in Electron webPreferences
- **Don't** expose entire Node.js or Electron APIs in preload - only specific, safe methods

## ffmpeg Integration Guidelines

### Current State
The export functionality is currently a **stub** that logs commands but doesn't execute them.

### Implementation Pattern for ffmpeg
```typescript
// In main.ts
ipcMain.handle('export:clip', async (event, sourcePath, clip) => {
  return new Promise((resolve, reject) => {
    const outputPath = path.join(/* output directory */, `${clip.name}.mp4`);
    
    const ffmpegArgs = [
      '-ss', clip.inSeconds.toString(),
      '-to', clip.outSeconds.toString(),
      '-i', sourcePath,
      '-c', 'copy', // Use -c copy for fast, lossless clipping
      outputPath
    ];
    
    const ffmpeg = spawn('ffmpeg', ffmpegArgs);
    
    ffmpeg.on('close', (code) => {
      if (code === 0) resolve(outputPath);
      else reject(new Error(`ffmpeg exited with code ${code}`));
    });
  });
});
```

### ffmpeg Best Practices for This Project
- Use `-ss` before `-i` for faster seeking
- Use `-c copy` for fast, lossless clipping when possible
- For re-encoding, use `-c:v libx264 -c:a aac`
- Handle stderr for progress updates
- Validate clip times before spawning ffmpeg
- Provide user feedback during export (progress bars, status messages)

## Project Extension Ideas

When implementing new features, consider these patterns:

### Project Persistence
```typescript
// Save project to JSON
interface ProjectData {
  version: string;
  sourcePath: string;
  clips: Clip[];
}

// Use Electron dialog to save/load .json files
// Store in application data directory for autosave
```

### Multiple Source Videos
```typescript
interface Clip {
  id: string;
  name: string;
  sourcePath: string; // Add source path to each clip
  inSeconds: number;
  outSeconds: number;
}
```

### Enhanced UI Features
- Use Video.js plugins for waveform visualization
- Implement drag-and-drop for timeline-based editing
- Add thumbnail generation using ffmpeg screenshot capability
- Use React DnD or similar for reorderable clip lists

### yt-dlp Integration
- Add IPC handler in main process to spawn yt-dlp
- Download to temp directory before opening in player
- Provide download progress feedback to renderer

## Testing Guidelines

### Testing Strategy (Future)
When implementing tests, follow these patterns:
- **Unit Tests**: Test utility functions and state management logic
- **Component Tests**: Test React components with React Testing Library
- **E2E Tests**: Test full workflows with Playwright or Spectron
- Mock Electron APIs in component tests
- Mock ffmpeg in integration tests

### Test File Naming
- Place tests next to source files: `VideoPlayer.test.tsx`
- Or use `__tests__` directory
- Use `.test.ts` or `.spec.ts` extension

## Development Environment

### Running the Application
```bash
# Start Vite dev server
npm run dev

# In another terminal, start Electron
npx electron .
```

### Building for Production
```bash
# Build renderer bundle
npm run build

# Package with electron-builder (when configured)
npm run package
```

### Development vs Production
- Development: Loads `http://localhost:5173` and opens DevTools
- Production: Loads from `dist/index.html`
- Check `app.isPackaged` or use environment variables to distinguish

## Additional Context

### Current Limitations (v0.1 Skeleton)
- No project save/load functionality
- ffmpeg export is stubbed (logs command but doesn't execute)
- No progress feedback during export
- Clips are not persisted between sessions
- Single source video per session
- No undo/redo functionality
- No clip editing (can only delete by recreating)

### Known Dependencies
- Requires ffmpeg installed on user's system (or bundled)
- Video.js handles most common video formats
- Electron security: contextIsolation enabled, nodeIntegration disabled

### Useful Resources
- [Electron IPC Documentation](https://www.electronjs.org/docs/latest/tutorial/ipc)
- [Video.js API Documentation](https://docs.videojs.com/)
- [ffmpeg Documentation](https://ffmpeg.org/ffmpeg.html)
- [React Context API](https://react.dev/reference/react/useContext)

---

**Remember**: This is a v0.1 skeleton designed for rapid iteration. Prioritize clear architecture and extensibility over feature completeness. When adding features, maintain the clean separation between main process (Electron/Node) and renderer process (React).
